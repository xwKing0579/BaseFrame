//
//  BFConfuseFile.m
//  BaseFrame
//
//  Created by ÁéãÁ••‰ºü on 2025/5/2.
//

#import "BFConfuseFile.h"
#import "BFConfuseManager.h"
#import "BFWordsRackTool.h"

@implementation BFConfuseFile

+ (NSDictionary *)fileMapping{
    return [self parseModuleMappingJSON:@"className"];
}

+ (NSDictionary *)fileMapping1{
    return [self parseModuleMappingJSON:@"className_xixi"];
}

+ (NSDictionary *)fileMapping2{
    return [self parseModuleMappingJSON:@"className_wsg"];
}

+ (NSDictionary *)fileMapping3{
    return [self parseModuleMappingJSON:@"className_jingyuege"];
}

+ (NSDictionary *)fileMapping0{
    return [self parseModuleMappingJSON:@"className_spamCode"];
}


//QMUIConfigurationTemplate
//HLHeaderModel
+ (NSDictionary *)fileMapping100{
    return [self parseModuleMappingJSON:@"className_yueyi"];
}

+ (NSDictionary *)fileMapping102{
    return [self parseModuleMappingJSON:@"className_yueyi 2"];
}

+ (NSDictionary *)fileMapping101{
    NSArray *list = [self parseModuleArrayJSON:@"className_nvliao"].allObjects;
    return @{};
}

+ (void)customReplaceInDirectory:(NSString *)directory replaceDict:(NSDictionary *)replaceDict{
    NSString *string = [BFConfuseManager readObfuscationMappingFileAtPath:directory];
    if (string){
        NSData *jsonData = [string dataUsingEncoding:NSUTF8StringEncoding];
        NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:jsonData options:kNilOptions error:nil];
        [BFConfuseFile replaceInDirectory:directory replaceDict:dict];
    }else{
        [BFConfuseManager writeData:replaceDict toPath:directory fileName:@"Ê∑∑Ê∑Ü/Êñá‰ª∂ÂêçÊò†Â∞Ñ"];
        [BFConfuseFile replaceInDirectory:directory replaceDict:replaceDict];
    }
}

+ (void)randomReplaceInDirectory:(NSString *)directory replaceDict:(NSDictionary *)replaceDict{
    NSArray *list = [self getTotalControllersInDirectory:directory];
    NSArray *wordList = [BFConfuseManager searchAndProcessArray:list withPrefixes:nil];
    
    NSString *string = [BFConfuseManager readObfuscationMappingFileAtPath:directory];
    if (string){
        NSData *jsonData = [string dataUsingEncoding:NSUTF8StringEncoding];
        NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:jsonData options:kNilOptions error:nil];
        [BFConfuseFile replaceInDirectory:directory replaceDict:dict];
    }else{
        NSArray *replaceList = [BFWordsRackTool getWordsWithType:ReadingWordsType];
        NSDictionary *dict = [BFConfuseManager wordList:wordList prefix:@"YDS" replaceList:replaceList exceptList:@[@"Model"] replactDict:@{@"View":@"V",@"Controller":@"C",@"Table":@"T"}];
        [BFConfuseManager writeData:dict toPath:directory fileName:@"Ê∑∑Ê∑Ü/Êñá‰ª∂ÂêçÊò†Â∞Ñ"];
        [BFConfuseFile replaceInDirectory:directory replaceDict:dict];
    }
}

+ (NSArray *)getTotalControllersInDirectory:(NSString *)directory{
    NSArray *exceptDirs = @[@"Pods"];
    NSArray *includeFiles = @[@"h",@"swift"];
    NSString *pattern = @"(?<=@interface\\s)[A-Za-z_][A-Za-z0-9_]*(?=\\s*:)";
    NSArray *list = [BFConfuseManager searchDirectory:directory exceptDirs:exceptDirs includeFiles:includeFiles regexPattern:pattern returnPatten:YES error:nil];
    NSMutableArray *result = [NSMutableArray arrayWithArray:list];
    [result removeObjectsInArray:@[@"SceneDelegate",@"AppDelegate"]];
    return result;
}

+ (void)replaceInDirectory:(NSString *)directory replaceDict:(NSDictionary *)replaceDict {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDirectoryEnumerator *enumerator = [fileManager enumeratorAtPath:directory];
    
    for (NSString *relativePath in enumerator) {
        NSString *fullPath = [directory stringByAppendingPathComponent:relativePath];
        
        // Ë∑≥ËøáPodsÁõÆÂΩï
        if ([relativePath containsString:@"Pods/"]) {
            [enumerator skipDescendants];
            continue;
        }
        
        BOOL isDirectory;
        [fileManager fileExistsAtPath:fullPath isDirectory:&isDirectory];
        
        // Âè™Â§ÑÁêÜÊñá‰ª∂
        if (!isDirectory) {
            NSString *fileExtension = [relativePath pathExtension];
            
            // Â§ÑÁêÜ.xcodeprojÊñá‰ª∂
            if ([fileExtension isEqualToString:@"pbxproj"]) {
                [self replaceInPbxprojFile:fullPath replaceDict:replaceDict];
            }
            // Â§ÑÁêÜÂÖ∂‰ªñÊåáÂÆöÁ±ªÂûãÁöÑÊñá‰ª∂
            else if ([self shouldProcessFileWithExtension:fileExtension]) {
                // ÂÖàÂ§ÑÁêÜÊñá‰ª∂ÂÜÖÂÆπÊõøÊç¢
                [self replaceInSourceFile:fullPath replaceDict:replaceDict];
                // ÁÑ∂ÂêéÂ§ÑÁêÜÊñá‰ª∂ÈáçÂëΩÂêç
                [self renameFileIfNeeded:fullPath relativePath:relativePath replaceDict:replaceDict];
            }
        }
    }
}

// Êñ∞Â¢ûÔºöÂ§ÑÁêÜÊ∫ê‰ª£Á†ÅÊñá‰ª∂ÂÜÖÂÆπÊõøÊç¢
+ (void)replaceInSourceFile:(NSString *)filePath replaceDict:(NSDictionary *)replaceDict {
    NSError *error = nil;
    NSMutableString *content = [NSMutableString stringWithContentsOfFile:filePath
                                                                encoding:NSUTF8StringEncoding
                                                                   error:&error];
    if (error) {
        NSLog(@"ËØªÂèñÂ§±Ë¥•: %@", filePath.lastPathComponent);
        return;
    }
    
    __block BOOL changesMade = NO;
    [replaceDict enumerateKeysAndObjectsUsingBlock:^(NSString *oldName, NSString *newName, BOOL *stop) {
        // ‰ΩøÁî®ÂçïËØçËæπÁïåÁ°Æ‰øùÂÆåÊï¥ÂåπÈÖçÔºåÂ§ßÂ∞èÂÜôÊïèÊÑü
        NSString *pattern = [NSString stringWithFormat:@"\\b%@\\b", [NSRegularExpression escapedPatternForString:oldName]];
        
        NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern
                                                                               options:0
                                                                                 error:nil];
        if (regex) {
            NSUInteger replacements = [regex replaceMatchesInString:content
                                                            options:0
                                                              range:NSMakeRange(0, content.length)
                                                       withTemplate:newName];
            if (replacements > 0) {
                changesMade = YES;
                NSLog(@"Âú® %@ ‰∏≠ÊõøÊç¢ÂÜÖÂÆπ %@ ‚Üí %@ (%luÂ§Ñ)", filePath.lastPathComponent, oldName, newName, (unsigned long)replacements);
            }
        }
    }];
    
    if (changesMade) {
        if (![content writeToFile:filePath
                       atomically:YES
                         encoding:NSUTF8StringEncoding
                            error:&error]) {
            NSLog(@"ÂÜôÂÖ•Â§±Ë¥•: %@", error.localizedDescription);
        }
    }
}

// ‰øùÊåÅÂéüÊúâÁöÑpbxprojÊñá‰ª∂Â§ÑÁêÜÊñπÊ≥ï
+ (void)replaceInPbxprojFile:(NSString *)pbxprojPath replaceDict:(NSDictionary *)replaceDict {
    NSError *error = nil;
    NSMutableString *content = [NSMutableString stringWithContentsOfFile:pbxprojPath
                                                                encoding:NSUTF8StringEncoding
                                                                   error:&error];
    if (error) {
        NSLog(@"ËØªÂèñÂ§±Ë¥•: %@", pbxprojPath.lastPathComponent);
        return;
    }
    
    __block BOOL changesMade = NO;
    [replaceDict enumerateKeysAndObjectsUsingBlock:^(NSString *oldName, NSString *newName, BOOL *stop) {
        NSString *pattern = [NSString stringWithFormat:@"(?<!\\w|\\+)%@(?=\\.(?:h|m|swift|mm)\\b)",[NSRegularExpression escapedPatternForString:oldName]];
        NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern
                                                                               options:0
                                                                                 error:nil];
        if (!error) {
            NSUInteger replacements = [regex replaceMatchesInString:content
                                                            options:0
                                                              range:NSMakeRange(0, content.length)
                                                       withTemplate:newName];
            if (replacements > 0) {
                changesMade = YES;
                NSLog(@"ÊõøÊç¢ %@ ‚Üí %@ (%luÂ§Ñ)", oldName, newName, (unsigned long)replacements);
            }
        }
    }];
    
    if (changesMade) {
        if (![content writeToFile:pbxprojPath
                       atomically:YES
                         encoding:NSUTF8StringEncoding
                            error:&error]) {
            NSLog(@"ÂÜôÂÖ•Â§±Ë¥•: %@", error.localizedDescription);
        }
    }
}

// Êñá‰ª∂ÈáçÂëΩÂêçÊñπÊ≥ïÔºà‰øùÊåÅÂéüÊúâÔºâ
+ (void)renameFileIfNeeded:(NSString *)fullPath
              relativePath:(NSString *)relativePath
               replaceDict:(NSDictionary *)replaceDict {
    
    NSString *fileName = [relativePath lastPathComponent];
    NSString *fileNameWithoutExtension = [fileName stringByDeletingPathExtension];
    NSString *fileExtension = [fileName pathExtension];
    
    // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÈáçÂëΩÂêçÔºàÂÆåÂÖ®ÂåπÈÖçÔºåÂ§ßÂ∞èÂÜôÊïèÊÑüÔºâ
    if (replaceDict[fileNameWithoutExtension]) {
        NSString *newFileName = [NSString stringWithFormat:@"%@.%@",
                                 replaceDict[fileNameWithoutExtension],
                                 fileExtension];
        NSString *newFullPath = [[fullPath stringByDeletingLastPathComponent]
                                 stringByAppendingPathComponent:newFileName];
        
        NSError *error;
        if ([[NSFileManager defaultManager] moveItemAtPath:fullPath
                                                    toPath:newFullPath
                                                     error:&error]) {
            NSLog(@"üîÑ ÈáçÂëΩÂêç: %@ -> %@", fileName, newFileName);
        } else {
            NSLog(@"‚ùå ÈáçÂëΩÂêçÂ§±Ë¥• %@: %@", fileName, error.localizedDescription);
        }
    }
}

// Âà§Êñ≠ÊòØÂê¶Â∫îËØ•Â§ÑÁêÜËØ•Êâ©Â±ïÂêçÁöÑÊñá‰ª∂
+ (BOOL)shouldProcessFileWithExtension:(NSString *)extension {
    // ‰øÆÊ≠£ÔºöÁßªÈô§.pchÂâçÁöÑÁÇπÂè∑
    NSArray *allowedExtensions = @[@"h", @"m", @"mm", @"swift", @"pch"];
    return [allowedExtensions containsObject:extension.lowercaseString];
}





//===================================================================
+ (void)globalReplaceInDirectory:(NSString *)directory
                         oldName:(NSString *)oldName
                         newName:(NSString *)newName {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDirectoryEnumerator *enumerator = [fileManager enumeratorAtPath:directory];
    
    // ÊîØÊåÅÁöÑÊñá‰ª∂Á±ªÂûã
    NSArray *supportedExtensions = @[@"h", @"m", @"mm", @"pbxproj", @"pch"];
    
    for (NSString *relativePath in enumerator) {
        NSString *fullPath = [directory stringByAppendingPathComponent:relativePath];
        
        if ([fullPath containsString:@"Pods"]) continue;
        
        
        // Ë∑≥ËøáÁõÆÂΩï
        BOOL isDirectory;
        [fileManager fileExistsAtPath:fullPath isDirectory:&isDirectory];
        if (isDirectory) {
            continue;
        }
        
        NSString *fileExtension = [[relativePath pathExtension] lowercaseString];
        
        // Ê£ÄÊü•Êñá‰ª∂Á±ªÂûã
        if (![supportedExtensions containsObject:fileExtension]) {
            continue;
        }
        
        // 1. Â§ÑÁêÜÊñá‰ª∂ÂÜÖÂÆπÊõøÊç¢
        [self replaceContentInFile:fullPath oldName:oldName newName:newName];
        
        // 2. Â§ÑÁêÜÊñá‰ª∂ÂêçÊõøÊç¢
        [self renameFileIfNeeded:fullPath oldName:oldName newName:newName];
        
    }
}

#pragma mark - Êñá‰ª∂ÂÜÖÂÆπÊõøÊç¢

+ (void)replaceContentInFile:(NSString *)filePath
                     oldName:(NSString *)oldName
                     newName:(NSString *)newName {
    NSError *error = nil;
    NSMutableString *content = [NSMutableString stringWithContentsOfFile:filePath
                                                                encoding:NSUTF8StringEncoding
                                                                   error:&error];
    if (error) {
        NSLog(@"‚ö†Ô∏è ËØªÂèñÂ§±Ë¥•: %@", filePath.lastPathComponent);
        return;
    }
    
    // ÂàõÂª∫ÂåπÈÖç‰∏âÁßçÊ®°ÂºèÁöÑÊ≠£ÂàôË°®ËææÂºèÔºàÂ§ßÂ∞èÂÜôÊïèÊÑüÔºâ
    NSString *basePattern = [NSString stringWithFormat:@"\\b%@\\b", [NSRegularExpression escapedPatternForString:oldName]];
    NSString *plusBasePattern = [NSString stringWithFormat:@"\\+%@\\b", [NSRegularExpression escapedPatternForString:oldName]];
    NSString *plusBaseDotPattern = [NSString stringWithFormat:@"\\+%@\\.", [NSRegularExpression escapedPatternForString:oldName]];
    
    NSString *combinedPattern = [NSString stringWithFormat:@"(%@)|(%@)|(%@)",
                                 basePattern, plusBasePattern, plusBaseDotPattern];
    
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:combinedPattern
                                                                           options:0
                                                                             error:&error];
    if (error) {
        NSLog(@"‚ùå Ê≠£ÂàôË°®ËææÂºèÈîôËØØ: %@", error.localizedDescription);
        return;
    }
    
    __block NSUInteger replacementCount = 0;
    
    // Ëé∑ÂèñÊâÄÊúâÂåπÈÖçÁªìÊûúÔºà‰ªéÂêéÂæÄÂâçÂ§ÑÁêÜÔºâ
    NSArray<NSTextCheckingResult *> *matches = [regex matchesInString:content
                                                              options:0
                                                                range:NSMakeRange(0, content.length)];
    
    for (NSTextCheckingResult *match in [matches reverseObjectEnumerator]) {
        NSRange matchedRange = match.range;
        NSString *matchedString = [content substringWithRange:matchedRange];
        
        // Á°ÆÂÆöÊõøÊç¢ÂÜÖÂÆπ
        NSString *replacement;
        if ([matchedString hasPrefix:@"+"] && [matchedString hasSuffix:@"."]) {
            replacement = [NSString stringWithFormat:@"+%@.", newName];
        } else if ([matchedString hasPrefix:@"+"]) {
            replacement = [NSString stringWithFormat:@"+%@", newName];
        } else {
            replacement = newName;
        }
        
        [content replaceCharactersInRange:matchedRange withString:replacement];
        replacementCount++;
    }
    
    if (replacementCount > 0) {
        if (![content writeToFile:filePath
                       atomically:YES
                         encoding:NSUTF8StringEncoding
                            error:&error]) {
            NSLog(@"‚ùå ÂÜôÂÖ•Â§±Ë¥•: %@", error.localizedDescription);
        } else {
            NSLog(@"‚úÖ %@: ÊõøÊç¢ %@ ‚Üí %@ (%luÂ§Ñ)",
                  filePath.lastPathComponent, oldName, newName, (unsigned long)replacementCount);
        }
    }
}

#pragma mark - Êñá‰ª∂ÂêçÊõøÊç¢

+ (void)renameFileIfNeeded:(NSString *)filePath
                   oldName:(NSString *)oldName
                   newName:(NSString *)newName {
    NSString *fileName = [filePath lastPathComponent];
    NSString *directory = [filePath stringByDeletingLastPathComponent];
    NSString *extension = [fileName pathExtension];
    NSString *fileNameWithoutExtension = [fileName stringByDeletingPathExtension];
    
    // ÈúÄË¶ÅÂ§ÑÁêÜÁöÑÂõõÁßçÊÉÖÂÜµ
    NSDictionary *replaceRules = @{
        oldName: newName,                                // Base ‚Üí NewBase
        [@"+" stringByAppendingString:oldName]:          // +Base ‚Üí +NewBase
        [@"+" stringByAppendingString:newName],
        [oldName stringByAppendingString:@"."]:          // Base. ‚Üí NewBase.
        [newName stringByAppendingString:@"."],
        [@"+" stringByAppendingString:oldName]:          // +Base. ‚Üí +NewBase.
        [@"+" stringByAppendingString:newName]
    };
    
    // Â§ÑÁêÜ Category ÂΩ¢ÂºèÁöÑÊñá‰ª∂Âêç (NSObject+Base)
    if ([fileNameWithoutExtension containsString:@"+"]) {
        NSArray *components = [fileNameWithoutExtension componentsSeparatedByString:@"+"];
        if ([components.lastObject isEqualToString:oldName]) {
            NSString *newFileNameWithoutExtension = [NSString stringWithFormat:@"%@+%@",
                                                     components.firstObject, newName];
            NSString *newFileName = [newFileNameWithoutExtension stringByAppendingPathExtension:extension];
            
            [self performRename:filePath
                    newFilePath:[directory stringByAppendingPathComponent:newFileName]
                       fileName:fileName];
            return;
        }
    }
    
    // Â§ÑÁêÜÊôÆÈÄöÊõøÊç¢ËßÑÂàô
    __block BOOL shouldRename = NO;
    __block NSString *newFileName = nil;
    
    [replaceRules enumerateKeysAndObjectsUsingBlock:^(NSString *oldPattern, NSString *newPattern, BOOL *stop) {
        // ÊÉÖÂÜµ1ÔºöÂÆåÊï¥Êñá‰ª∂ÂêçÂåπÈÖçÔºàÊó†Êâ©Â±ïÂêçÔºâ
        if ([fileName isEqualToString:oldPattern]) {
            shouldRename = YES;
            newFileName = newPattern;
            *stop = YES;
        }
        // ÊÉÖÂÜµ2ÔºöÊñá‰ª∂ÂêçÂâçÁºÄÂåπÈÖçÔºàÂ∏¶Êâ©Â±ïÂêçÔºâ
        else if ([fileNameWithoutExtension isEqualToString:oldPattern]) {
            shouldRename = YES;
            newFileName = [newPattern stringByAppendingPathExtension:extension];
            *stop = YES;
        }
        // ÊÉÖÂÜµ3ÔºöÂ∏¶ÁÇπÂè∑ÁöÑÁâπÊÆäÊÉÖÂÜµ
        else if ([fileNameWithoutExtension hasSuffix:oldPattern] &&
                 [fileNameWithoutExtension length] > [oldPattern length]) {
            shouldRename = YES;
            NSString *prefix = [fileNameWithoutExtension substringToIndex:
                                fileNameWithoutExtension.length - oldPattern.length];
            newFileName = [[prefix stringByAppendingString:newPattern]
                           stringByAppendingPathExtension:extension];
            *stop = YES;
        }
    }];
    
    if (shouldRename) {
        [self performRename:filePath
                newFilePath:[directory stringByAppendingPathComponent:newFileName]
                   fileName:fileName];
    }
}

+ (void)performRename:(NSString *)oldPath
          newFilePath:(NSString *)newPath
             fileName:(NSString *)fileName {
    NSError *error;
    if ([[NSFileManager defaultManager] moveItemAtPath:oldPath
                                                toPath:newPath
                                                 error:&error]) {
        NSLog(@"üîÑ ÈáçÂëΩÂêçÊàêÂäü: %@ ‚Üí %@", fileName, [newPath lastPathComponent]);
    } else {
        NSLog(@"‚ùå ÈáçÂëΩÂêçÂ§±Ë¥• %@: %@", fileName, error.localizedDescription);
    }
}





@end
